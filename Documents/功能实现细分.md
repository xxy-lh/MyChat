# Telegram 聊天系统 - 功能实现细分 (v2.0)

文档三：功能实现细分 (逻辑修正版)

这份文档的修改重点在于**逻辑流程**。原文档是基于“单机”思维写的，现在我将其修正为基于**“分布式 + 高并发”**的思维。

* **ID**: 强制改为雪花算法。
* **消息**: 强制改为 Redis Pub/Sub 路由。
* **未读数**: 强制改为 Redis 原子计数。

## 📋 目录

1. [基础设施实现](#1-基础设施实现)
2. [用户与认证逻辑](#2-用户与认证逻辑)
3. [核心聊天逻辑](#3-核心聊天逻辑)
4. [好友与关系逻辑](#4-好友与关系逻辑)

---

## 1. 基础设施实现

### 1.1 全局唯一 ID (Snowflake)

* **问题**: 数据库自增 ID 会暴露数据量，且不利于分库分表。
* **方案**: 在 `infrastructure` 模块实现 Twitter 雪花算法。
* **应用**: 所有表的主键 (`User.id`, `Message.id`) 均在 Java 代码中生成后插入，而非依赖数据库。

### 1.2 Redis 键设计 (Schema)

* `user:token:{userId}` -> 登录令牌 (TTL)
* `user:online:{userId}` -> 在线状态 (Set/String)
* `chat:unread:{userId}:{senderId}` -> 未读消息数 (Atomic Integer)
* `sys:seq:chat` -> 消息序列号 (用于前端同步)

---

## 2. 用户与认证逻辑

### 2.1 用户注册

**逻辑流程**:

1. **校验**: 检查手机号是否已存在（Redis 缓存布隆过滤器预判 + DB 查重）。
2. **ID 生成**: 调用 `SnowflakeIdGenerator.nextId()` 获取用户 ID。
3. **入库**: 使用 JPA `repository.save(user)` 保存，密码必须 BCrypt 加密。
4. **初始化**: 为新用户创建默认设置（隐私配置等）。

### 2.2 用户登录

**逻辑流程**:

1. **认证**: 校验账号密码。
2. **双令牌**: 生成 `AccessToken` (短效) 和 `RefreshToken` (长效)。
3. **缓存**: 将 Token 存入 Redis 白名单，用于后续强制踢下线功能。

---

## 3. 核心聊天逻辑 (最复杂部分)

### 3.1 发送消息 (Upstream)

**场景**: 用户 A 发送消息给 用户 B。
**逻辑流程**:

1. **接收**: WebSocket Controller 接收 Payload。
2. **构建**: 生成消息 ID，标记时间戳，设置状态为 `SENDING`。
3. **持久化**:
   * 启动虚拟线程。
   * 写入 MySQL `message` 表。
4. **扩散 (关键)**:
   * 将消息序列化。
   * 通过 `RedisTemplate.convertAndSend("chat.topic", msg)` 广播到所有服务器节点。
5. **反馈**: 给发送者 A 回复 `ACK` (消息已送达服务器)。

### 3.2 接收消息 (Downstream)

**场景**: 服务器节点监听到 Redis 广播。
**逻辑流程**:

1. **监听**: `RedisMessageListener` 收到消息体。
2. **路由**: 检查 接收者 B 是否连接在**当前**这台服务器的 WebSocket Session 中。
   * **是**: 直接通过 Session 推送消息给 B。
   * **否**: 忽略（说明 B 连在其他机器上，或者 B 离线）。
3. **通知**: 如果 B 离线，调用推送服务（FCM/APNs）发送系统通知。

### 3.3 未读数管理

**逻辑流程**:

* **增加**: 消息落库时，执行 `Redis.incr("chat:unread:{B}:{A}")`。
* **清零**: 当 B 打开与 A 的聊天窗口，前端发送 `READ` 动作，后端执行 `Redis.del` 并异步更新数据库状态。

---

## 4. 好友与关系逻辑

### 4.1 添加好友

**逻辑流程**:

1. **锁**: 使用 `Redisson` 分布式锁或数据库唯一索引 (`unique_from_to`)，防止重复发送请求。
2. **状态机**:
   * 状态 0: 申请中
   * 状态 1: 已通过
   * 状态 2: 已拒绝
3. **双向关系**: 好友通过后，在 `user_friend` 表插入两条记录 (A->B, B->A)，方便查询。

### 4.2 黑名单

**逻辑流程**:

* 拉黑操作不仅更新数据库，必须同步更新 Redis 中的 `user:block:{userId}` 集合。
* 消息发送前，先通过 Redis 校验是否存在拉黑关系（为了极速拦截）。

```

```
